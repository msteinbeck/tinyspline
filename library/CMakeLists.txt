cmake_minimum_required(VERSION 2.8)

# setup some convenience variables
set(TS_AVR_CROSSCOMPILE FALSE)
if(CMAKE_SYSTEM_PROCESSOR MATCHES "avr")
  set(TS_AVR_CROSSCOMPILE TRUE)
endif()

# determine whether shared libs are supported by target and setup
# TARGET_SUPPORTS_SHARED_LIBS
if(NOT DEFINED TARGET_SUPPORTS_SHARED_LIBS)
  set(TARGET_SUPPORTS_SHARED_LIBS TRUE) # by default we claim yes
  if(TS_AVR_CROSSCOMPILE)
    set(TARGET_SUPPORTS_SHARED_LIBS FALSE)
    # check further targets if necessary
  endif()
endif()

# determine the used compiler and its version, configure compiler flags,
# and setup TS_CPP_AVAILABLE
set(TS_CPP_AVAILABLE FALSE) # by default the c++ library is not created
if(CMAKE_CXX_COMPILER_ID MATCHES "GNU")
  set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Werror -Wall -Wextra -Wfloat-equal -pedantic")
  # avr uses the 'inline' keyword in some header files which is not
  # supported by c89
  if(TS_AVR_CROSSCOMPILE)
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -std=c99")
  else()
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -std=c89")
  endif()

  # http://stackoverflow.com/questions/10984442/how-to-detect-c11-support-of-a-compiler-with-cmake
  if(CMAKE_CXX_COMPILER_VERSION VERSION_GREATER 4.7 OR CMAKE_CXX_COMPILER_VERSION VERSION_EQUAL 4.7)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Werror -Wall -Wextra -Wfloat-equal -std=c++11")
    # fixes some warnings of source files generated by swig
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fno-strict-aliasing")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wno-missing-field-initializers")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wno-unused-parameter")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wno-unused-but-set-variable")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wno-ignored-qualifiers")
    set(TS_CPP_AVAILABLE TRUE)
  endif()
elseif(CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  # do not use -ansi with clang
  set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Werror -Wall -Wextra -Wfloat-equal -pedantic -std=c89")

  # http://stackoverflow.com/questions/10408849/how-can-i-use-c-11-features-in-clang
  if(CMAKE_CXX_COMPILER_VERSION VERSION_GREATER 3.3 OR CMAKE_CXX_COMPILER_VERSION VERSION_EQUAL 3.3)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Werror -Wall -Wextra -Wfloat-equal -std=c++11")
    # fixes some warnings of source files generated by swig
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wno-missing-field-initializers")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wno-unused-parameter")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wno-ignored-qualifiers")
    set(TS_CPP_AVAILABLE TRUE)
  endif()
elseif(CMAKE_CXX_COMPILER_ID MATCHES "MSVC")
  set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} /Wall /WX /wd4820 /wd4711 /wd4255")

  if(CMAKE_CXX_COMPILER_VERSION VERSION_GREATER 18 OR CMAKE_CXX_COMPILER_VERSION VERSION_EQUAL 18
     OR NOT TS_CPP_WITH_MOVE_SEMANTICS )
    # using WX causes to many errors in generated source code, thus, use W4 instead
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /Wall /W4 /wd4702")
    set(TS_CPP_AVAILABLE TRUE)
  endif()
elseif(CMAKE_CXX_COMPILER_ID STREQUAL "Intel")
  # TODO: check for version 2014 or greater
  set(TS_CPP_AVAILABLE TRUE)
endif()
# disable the c++ library for specific targets by hand
if(TS_AVR_CROSSCOMPILE)
  set(TS_CPP_AVAILABLE FALSE) # avr is missing some required headers
  # check further targets if necessary
endif()

# create c libs
if(TARGET_SUPPORTS_SHARED_LIBS)
  add_library(tinyspline_shared SHARED tinyspline.c)
  set_target_properties(tinyspline_shared PROPERTIES OUTPUT_NAME "tinyspline")
  install(TARGETS tinyspline_shared
    LIBRARY DESTINATION lib
    ARCHIVE DESTINATION lib
  )
endif()
add_library(tinyspline_static STATIC tinyspline.c)
set_target_properties(tinyspline_static PROPERTIES OUTPUT_NAME "tinyspline")
install(TARGETS tinyspline_static
  LIBRARY DESTINATION lib
  ARCHIVE DESTINATION lib
)
install(FILES tinyspline.h
  DESTINATION include
)

# create c++ libs
if(TS_CPP_AVAILABLE)
  if(TARGET_SUPPORTS_SHARED_LIBS)
    add_library(tinysplinecpp_shared SHARED tinyspline.c tinysplinecpp.cpp)
    set_target_properties(tinysplinecpp_shared PROPERTIES OUTPUT_NAME "tinysplinecpp")
    install(TARGETS tinysplinecpp_shared
      LIBRARY DESTINATION lib
      ARCHIVE DESTINATION lib
    )
  endif()
  add_library(tinysplinecpp_static STATIC tinyspline.c tinysplinecpp.cpp)
  set_target_properties(tinysplinecpp_static PROPERTIES OUTPUT_NAME "tinysplinecpp")
  install(TARGETS tinysplinecpp_static
    LIBRARY DESTINATION lib
    ARCHIVE DESTINATION lib
  )
  install(FILES tinysplinecpp.h
    DESTINATION include
  )
endif()

# create bindings
if(DEFINED ENV{SWIG_EXECUTABLE})
  message(STATUS "Using environment variable SWIG_EXECUTABLE")
  set(SWIG_EXECUTABLE $ENV{SWIG_EXECUTABLE})
endif()
find_package(SWIG 3.0.1)
if(TS_CPP_AVAILABLE AND SWIG_FOUND AND TARGET_SUPPORTS_SHARED_LIBS)
  include(${SWIG_USE_FILE})
  include_directories(${CMAKE_CURRENT_SOURCE_DIR})

  # define the output dirs
  set(TS_GENERATED_PYTHON_DIR ${CMAKE_CURRENT_BINARY_DIR}/python CACHE STRING "Output folder for Python binding")
  set(TS_GENERATED_JAVA_DIR ${CMAKE_CURRENT_BINARY_DIR}/so/tinyspline CACHE STRING "Output folder for Java binding")
  set(TS_GENERATED_CSHARP_DIR ${CMAKE_CURRENT_BINARY_DIR}/csharp CACHE STRING "Output folder for CSHARP binding")
  set(TS_GENERATED_RUBY_DIR ${CMAKE_CURRENT_BINARY_DIR}/ruby CACHE STRING "Output folder for Ruby binding")

  # python
  if( TS_BINDING_PYTHON )
    if(DEFINED ENV{PYTHON_LIBRARY} AND DEFINED ENV{PYTHON_INCLUDE_DIR})
      message(STATUS "Using environment variables PYTHON_LIBRARY and PYTHON_INCLUDE_DIR")
      set(PYTHON_LIBRARY $ENV{PYTHON_LIBRARY})
      set(PYTHON_INCLUDE_DIR $ENV{PYTHON_INCLUDE_DIR})
    endif()
    find_package(PythonLibs)
    if (PYTHONLIBS_FOUND)
      include_directories(${PYTHON_INCLUDE_DIRS})
      set_source_files_properties(tinysplinepython.i PROPERTIES CPLUSPLUS ON)
      if (${PYTHONLIBS_VERSION_STRING} MATCHES "^3.")
        message(STATUS "Using Python 3 mode.")
        set(CMAKE_SWIG_FLAGS -py3 -O)
      else()
        message(STATUS "Using Python 2 mode.")
        set(CMAKE_SWIG_FLAGS -O)
      endif()
      set(CMAKE_SWIG_OUTDIR ${TS_GENERATED_PYTHON_DIR})
      swig_add_module(tinysplinepython python tinysplinepython.i tinyspline.c tinysplinecpp.cpp)
      swig_link_libraries(tinysplinepython ${PYTHON_LIBRARIES})
      # for some reason the generated make target for python is _tinysplinepython
      add_custom_command(TARGET _tinysplinepython POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy ${TS_GENERATED_PYTHON_DIR}/tinysplinepython.py
        ${CMAKE_CURRENT_BINARY_DIR}/tinyspline.py
      )
      set_target_properties(_tinysplinepython PROPERTIES FOLDER "bindings")
    endif()
  endif()

  # java
  if( TS_BINDING_JAVA )
    find_package(JNI)
    if(JNI_FOUND)
      include_directories(${JAVA_INCLUDE_PATH} ${JAVA_INCLUDE_PATH2})
      set_source_files_properties(tinysplinejava.i PROPERTIES CPLUSPLUS ON)
      set(CMAKE_SWIG_FLAGS -package "so.tinyspline" -O)
      set(CMAKE_SWIG_OUTDIR ${TS_GENERATED_JAVA_DIR})
      swig_add_module(tinysplinejava java tinysplinejava.i tinyspline.c tinysplinecpp.cpp)
      swig_link_libraries(tinysplinejava ${JAVA_LIBRARIES})
      
      find_package(Java COMPONENTS Development)
      if(Java_Development_FOUND)
        include(UseJava)
        add_jar(tinysplinejar 
          ${TS_GENERATED_JAVA_DIR}/SWIGTYPE_p_float.java
          ${TS_GENERATED_JAVA_DIR}/SWIGTYPE_p_size_t.java
          ${TS_GENERATED_JAVA_DIR}/SWIGTYPE_p_tsBSpline.java
          ${TS_GENERATED_JAVA_DIR}/SWIGTYPE_p_tsDeBoorNet.java
          ${TS_GENERATED_JAVA_DIR}/SWIGTYPE_tsError.java
          ${TS_GENERATED_JAVA_DIR}/tinysplinejava.java
          ${TS_GENERATED_JAVA_DIR}/tinysplinejavaJNI.java
          ${TS_GENERATED_JAVA_DIR}/BSpline.java
          ${TS_GENERATED_JAVA_DIR}/tsBSplineType.java
          ${TS_GENERATED_JAVA_DIR}/DeBoorNet.java
          ${TS_GENERATED_JAVA_DIR}/FloatVector.java
          OUTPUT_NAME tinyspline
        )
        add_dependencies(tinysplinejar tinysplinejava)
        set_target_properties(tinysplinejar PROPERTIES FOLDER "bindings")
      endif()
      
      set_target_properties(tinysplinejava PROPERTIES FOLDER "bindings")
    endif()
  endif()

  # csharp
  if( TS_BINDING_CSHARP )
    set_source_files_properties(tinysplinecsharp.i PROPERTIES CPLUSPLUS ON)
    set(CMAKE_SWIG_FLAGS -namespace ts -O)
    set(CMAKE_SWIG_OUTDIR ${TS_GENERATED_CSHARP_DIR})
    swig_add_module(tinysplinecsharp csharp tinysplinecsharp.i tinyspline.c tinysplinecpp.cpp)
    find_program(CSHARP_COMPILER
      NAMES csc mcs dmcs gmcs
      PATHS "C:/Windows/Microsoft.NET/Framework/v3.5/bin"
    )
    if(NOT CSHARP_COMPILER)
      message(STATUS "Could NOT find any suitable C# compiler.")
    else()
      message(STATUS "Using ${CSHARP_COMPILER} to compile C# sources.")
      # append 'cs' to assembly name to ensure it doesn't clash
      # with the c library.
      add_custom_command(TARGET tinysplinecsharp POST_BUILD
        COMMAND ${CSHARP_COMPILER} /t:library /sdk:2 /recurse:"${TS_GENERATED_CSHARP_DIR}/*.cs" /out:tinysplinecs.dll
      )
    endif()
    set_target_properties(tinysplinecsharp PROPERTIES FOLDER "bindings")
  endif()

  # ruby
  if( TS_BINDING_RUBY )
    find_package(Ruby)
    if(RUBY_FOUND)
      include_directories(${RUBY_INCLUDE_DIRS})
      set_source_files_properties(tinysplineruby.i PROPERTIES CPLUSPLUS ON)
      set(CMAKE_SWIG_FLAGS -O)
      set(CMAKE_SWIG_OUTDIR ${TS_GENERATED_RUBY_DIR})
      swig_add_module(tinysplineruby ruby tinysplineruby.i tinyspline.c tinysplinecpp.cpp)
      swig_link_libraries(tinysplineruby ${RUBY_LIBRARY})
      # for additional information please see the 'tinysplineruby.i' SWIG file.
      file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/tinyspline.rb  "require 'tinysplineruby'\n")
      file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/tinyspline.rb "\n")
      file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/tinyspline.rb "module Tinyspline\n")
      file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/tinyspline.rb "  class BSpline < Tinysplineruby::BSpline\n")
      file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/tinyspline.rb "    def ctrlp=(ctrlp)\n")
      file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/tinyspline.rb "      setCtrlp(ctrlp)\n")
      file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/tinyspline.rb "    end\n")
      file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/tinyspline.rb "\n")
      file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/tinyspline.rb "    def knots=(knots)\n")
      file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/tinyspline.rb "      setKnots(knots)\n")
      file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/tinyspline.rb "    end\n")
      file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/tinyspline.rb "  end\n")
      file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/tinyspline.rb "\n")
      file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/tinyspline.rb "  class DeBoorNet < Tinysplineruby::DeBoorNet\n")
      file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/tinyspline.rb "  end\n")
      file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/tinyspline.rb "\n")
      file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/tinyspline.rb "  class Utils < Tinysplineruby::Utils\n")
      file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/tinyspline.rb "  end\n")
      file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/tinyspline.rb "end")
      set_target_properties(tinysplineruby PROPERTIES FOLDER "bindings")
    endif()
  endif()

  # add additional clean targets
  set_directory_properties(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES 
    "${TS_GENERATED_PYTHON_DIR};${CMAKE_CURRENT_BINARY_DIR}/tinyspline.py;${CMAKE_CURRENT_BINARY_DIR}/so;${TS_GENERATED_CSHARP_DIR};${CMAKE_CURRENT_BINARY_DIR}/tinysplinecs.dll;${TS_GENERATED_RUBY_DIR};${CMAKE_CURRENT_BINARY_DIR}/tinyspline.rb"
  )
endif()

# make static lib of tinyspline available for examples
target_include_directories(tinyspline_static PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
